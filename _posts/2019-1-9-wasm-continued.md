---
layout: post
title: "WebAssembly 续篇"
---

夜深了，这个玩意儿我可能会写两天。但是没关系，既然我决定要写点儿东西了，我就不能停下来。我们上回说到了 [WebAssembly](https://webassembly.org) 世界中的你好世界，然后现在我们知道了，用近乎 native 的速度在浏览器上跑东西的确是可能的。但是你可能同时也发现了一点，那就是：

** 他默认的界面也太丑了吧。。。 **

![丑恶的界面](/assets/ugly_interface.png)

总之，我相信在将来的某一天，你会讨厌这个画面的。于是，这就给我们带出来了另外一个问题：** 怎么样直接在自己写的页面里面调用 wasm 里头的方法呢？ **

往回看，一开始编译好的时候，你会发现他生成了三个东西，每个都有自己不同的后缀，分别是：
- `xxx.wasm`
- `xxx.js`
- `xxx.html`

实际上，`xxx.js` 跟 `xxx.wasm` 才是这个的核心，编译好的 html 只不过是一个壳而已。你甚至可以找到这个壳的位置，他就在 `[emcc安装路径]/[某个版本号]/src/shell.html` 中。如果你对这个默认界面不满意，你是可以在编译 html 的时候更换模版的，但我不准备说这个了，上网找找你就知道了。回到正题，也就是`xxx.wasm` 跟 `xxx.js` 才是核心，对吧？所以也就是说，我完全可以新建一个我自己喜欢的页面，然后引用他们了。实际上这非常简单，而且虽然很简单，但我还是想说一下这个步骤，不然文章看起来挺短的。

_注意：打后， `xxx` 全部用 `main` 替换，反正就是指你编译好的那一堆文件。因为 `xxx` 看起来太别扭了。 `main` 是我上一条推中用的名字，你可以去看看。_

废话少说，我们要怎么做呢？

## 新建一个空网页 
新建一个文件，就叫 `index.html` 吧。

## 往里面填你自己喜欢的内容
你在里面想加什么都行。

## 加上这句引用：
`<script src="main.js"></script>`

接下来，我们直接打开我们的 [本地服务器](http://127.0.0.1:8080) ，就可以看到一个上面是你的内容的网页了。然后进入检索/开发者模式的控制台，你就可以发现 main 会被自动执行，并且 hello world 会输出在你的控制台中。真好！再也不用看那个丑的一批的界面了。

## 引出了新的问题
但是，这样又有了新的问题了。既然我都已经可以用自己的 html 了，是不是也就意味着我能够什么时候调用 wasm 的方法都行呢？因为有的时候我们的确不想他一开始就运行一个 main()，输出句话，然后退出。有的时候我们会想等待用户的输入，然后再执行相应的 wasm 代码。

在 emcc 之中，你编译好的方法一般会存在于 `window.Module.asm` 当中: 
![补全](/assets/autocomplete.png)

你可以看到，`malloc`, `free`, `main` 之类的以前面加了条下划线的形式存在于里面。其实你还可以尝试调用一下：
`_main()` 

你就可以发现，的确是可以执行的。

## 除了 main 以外的方法呢？
但是，对于 main 以外的， main 又没有调用的函数， `emcc` 可不是这样对待的。他会把这些全部当成死代码，然后在编译的时候一并删掉。那怎么保持它们存活呢？其实很简单，这里以一个 `int addOne(int what)` 为例： 

```
int EMSCRIPTEN_KEEPALIVE addOne(int what) {
    return what + 1;
}
```

可以看得到，唯一不同的就是多了一个 `EMSCRIPTEN_KEEPALIVE` 在函数签名那。这个宏可以防止 emcc/em++ 在编译的时候删掉这个函数。你也可以尝试编译一下，然后完了以后打开 [本地服务器](http://127.0.0.1:8080) ，并且输入 `_addOne(100)`。正常来说，应该会输出 101 的，对吧？也就是说，你现在掌握了一半怎么样在 Javascript 中调用 wasm 的内容了！

## 一半？
未完待续。。。考试去了

