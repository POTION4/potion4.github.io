<!doctype html>
<html lang="zh">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="msvalidate.01" content="D1B532AF972A1AB6C3525C904A9AC816" />
  <meta name="google-site-verification" content="-ujy_zWUIaX-QJ4vdUYfXThyZgr_KqsU0lL611rqsy8" />
  <title>恶心的二进制算法</title>
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/app.js"></script>
</head>

  <body>
    <div id="contentPane" class="huge-page real main">
      <h1><a href="/">Frame of 42yeah</a></h1>
      <h2>恶心的二进制算法</h2>
      <hr />
      <section>
        <div style="margin-bottom: -25px">
  <div id='MicrosoftTranslatorWidget' class='Dark' style='color:white;background-color:inherit;height:30px;'></div>
</div>

<script type='text/javascript'>
  setTimeout(function(){
    {var s=document.createElement('script');s.type='text/javascript';s.charset='UTF-8';s.src=((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=ueOIGRSKkd965FeEGM5JtQ**&ctf=False&ui=true&settings=Manual&from=';var p=document.getElementsByTagName('head')[0]||document.documentElement;p.insertBefore(s,p.firstChild); }
  },0);
</script>
<script type='text/javascript' src='//www.bing.com/widget/bootstrap.js' data-id='cc2030a35e7345a1940e909993402b13' data-version='1.0b' data-autosnapshot='false' async></script>
        <p>这几天在学这些玩意…… 然后最恶心的莫过于二进制的乘和二进制的除了！在这儿，为了防止我忘记，我主要说 Booth 乘法和二进制除法 - 保留余数和原码加减交替除法。</p>

<h2 id="booth-算法">Booth 算法</h2>

<p>我没打算解释的太过清楚，主要是说一下过程。因为网上相关的文献已经很多了，但是说的很通俗的却没几个。我今天就要用贼几把通俗的语言去解释他们！</p>

<p>先确认一些名词。</p>

<p>在 <code class="highlighter-rouge">0011 * 0111 (3 * 7)</code> 内， <code class="highlighter-rouge">0011</code> 被称为 <strong>被乘数</strong> ， <code class="highlighter-rouge">0111</code> 被称为 <strong>乘数</strong> 。</p>

<p>开波！Booth 算法的大体结构如下：</p>

<ol>
  <li>初始化 P 为 0</li>
  <li>在乘数的最右边加一个 0 (本来被乘数为 <code class="highlighter-rouge">0111</code> ，现在变成了 <code class="highlighter-rouge">01110</code>)</li>
  <li>看看乘数的倒数 1，2 位是啥：
    <ul>
      <li>00 ? 啥也不做</li>
      <li>01 ? 把被乘数加去 P 那</li>
      <li>10 ? 把被乘数从 P 中减出来</li>
      <li>11 ? 啥也不做</li>
    </ul>
  </li>
  <li>把被乘数乘以 2 (也就是后面跟个 0)</li>
  <li>看看乘数的倒数 2，3 位是啥，重复<strong>第 3 步 和第 4 步</strong></li>
  <li>当被乘数已经一直看过去看到没东西能再看的时候，P 就是乘法的结果了。</li>
</ol>

<p>咱们来看看 3 * 7:</p>

<ol>
  <li>P = 0</li>
  <li>乘数 = 01110</li>
  <li>最后两位为 011<u>10</u></li>
  <li>P = P - 被乘数, P = 11.1101 (其中 11. 是符号位，用两位符号位是为的防溢出)</li>
  <li>被乘数翻倍, 被乘数 = 00110</li>
  <li>最后两位为 01<u>11</u>0</li>
  <li>啥也不做</li>
  <li>被乘数翻倍，被乘数 = 001100</li>
  <li>最后两位为 0<u>11</u>10</li>
  <li>啥也不做</li>
  <li>被乘数翻倍，被乘数 = 0011000</li>
  <li>最后两位为 <u>01</u>110</li>
  <li>P = P + 被乘数。<strong>注意！</strong>此时的 P 因为位数实际上和被乘数完全不相等，所以 P 是会顺延的！跟被乘数缺失的位数，P 会全部用符号位相应的数字补上，也就是说 P 现在是 11.1111101 。 11.1111101 + 00.0011000 = 00.0010101 。</li>
  <li>被乘数翻倍（其实已经没必要了），被乘数 = 00110000</li>
  <li>一看，咦，乘数被我走完了！所以答案就是 10101，也就是……</li>
  <li>21! 惊不惊喜？</li>
</ol>

<h2 id="保留余数的除法">保留余数的除法</h2>

<p>嗯…… 我们假设我们要计算 <code class="highlighter-rouge">X / Y</code> ，好吧</p>

<ol>
  <li>初始化 Q 为 “” (空)</li>
  <li>把 X 取绝对值，把 Y 取绝对值，并且获得 Y 绝对值的负数的反码，我就直接叫 -Y 好了……譬如如果 Y 原本等于 = 3，那么到了这一步，Y = 00.0011 ， -Y = 11.1101，可以吧？</li>
  <li><code class="highlighter-rouge">X = X - Y</code></li>
  <li>X &lt; 0 ? <code class="highlighter-rouge">X = X + Y</code> (其实就是恢复旧 X) ，并且 Q = Q + “0” 。否则 Q = Q + “1” <strong>注意！这里要看情况加小数点</strong></li>
  <li>X = X 左移一位（包括符号位，如果最高位为 1 的话那那个 1 就应该进入符号位的低位）</li>
  <li>就这么循环 3, 4, 5 一直算，直到你算腻了或者 <code class="highlighter-rouge">X == 0</code> 为止。结果就是 Q，余数就是结果的小数点位.X 。</li>
</ol>

<p>咱们来看看 3 / 7：</p>

<ol>
  <li>Q = “”</li>
  <li>X = 00.0011, Y = 00.0111, -Y = 11.1001</li>
  <li>X = X - Y = 11.1100, 所以 X = X + Y = 00.0011, 且 Q = “0”</li>
  <li>X = X 左移一位，X = 00.0110</li>
  <li>X = X - Y = 11.1111, 所以 X = X + Y = 00.0110, Q = “0.0” (这个小数点自己看情况加吧……这里就很明显应该加了)</li>
  <li>X = X 左移一位 = 00.1100</li>
  <li>X = X - Y = 00.0101, Q = “0.01”</li>
  <li>X = X 左移一位 = 00.1010</li>
  <li>X = X - Y = 00.0011, Q = “0.011”</li>
  <li>X = X 左移一位 = 00.0110 
发现了吗？这玩意儿死循环了。所以 Q 应该等于 0.011011011011…，所以与此同时，让我们来看看我们算到 Q = “0.011” 的时候的余数吧。</li>
  <li>余数很容易看，我们可以发现， X 如今是 00.0110，因此余数 = 结果的小数点位.X = 0.<u>000</u>0110 (因为结果小数点后有 3 个数字(0.011) ，所以 X 前面补 3 个 0 就是他的余数了)</li>
</ol>

<p>那么 0.011 是多少呢？0.375! 3/7 又等于多少呢？0.428571428571429 。有人可能问了，这俩玩意完全不想等呀！那是因为我们算的位太少了。假如我们算这个的话：</p>

<ul>
  <li>0.011011 = 0.421875</li>
  <li>0.011011011 = 0.427734375</li>
</ul>

<p>发现了吧？精度越高，咱算的越准。</p>

<h2 id="加减交替除法">加减交替除法</h2>

<p>这玩意跟保留余数算法很像，我就不做例子了，你一定能理解的</p>

<ol>
  <li>初始化 Q 为 “” (空)</li>
  <li>把 X 取绝对值，把 Y 取绝对值，并且获得 Y 绝对值的负数的反码，我就直接叫 -Y 好了……譬如如果 Y 原本等于 = 3，那么到了这一步，Y = 00.0011 ， -Y = 11.1101，可以吧？ 
3.XX &gt; 0 ? <code class="highlighter-rouge">X = X - Y</code> : <code class="highlighter-rouge">X = X + Y</code></li>
  <li>X &lt; 0 ? Q = Q + “0” : Q = Q + “1” <strong>注意！这里要看情况加小数点</strong></li>
  <li>如果你算腻了或者 <code class="highlighter-rouge">X == 0</code> ，退出。</li>
  <li>X = X 左移一位（包括符号位，如果最高位为 1 的话那那个 1 就应该进入符号位的低位）</li>
</ol>

<p>为止。结果就是 Q，余数就是结果的小数点位.X 。<strong>注意注意注意！如果你腻了，那么在刚刚算好 Q 之后就不要再移位 X 了！也就是说，这里跟保留余数不一样的另外一个地方就是在最后一次计算时，X 不会移位！</strong>所以我把他们俩的顺序调换了，发现了吗？</p>

<p>例子我就不举了，就这样啦！祝大家玩得愉快……吧……</p>

      </section>
      <h2 id="评论区">评论区</h2>
<div id="disqus_thread" style="font-size: 12px !important;"></div>
<script>
  var disqus_config = function () {
    this.page.url = "https://potion4.github.io/algorithm/2019/04/03/binary-algorithms.html";
    this.page.identifier = "恶心的二进制算法";
  };

  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://frame-of-42yeah.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>
  </body>
</html>
