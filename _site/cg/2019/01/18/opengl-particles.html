<!doctype html>
<html lang="zh">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="msvalidate.01" content="D1B532AF972A1AB6C3525C904A9AC816" />
  <meta name="google-site-verification" content="-ujy_zWUIaX-QJ4vdUYfXThyZgr_KqsU0lL611rqsy8" />
  <title>粒子系统！</title>
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/app.js"></script>
</head>

  <body>
    <div id="contentPane" class="huge-page real main">
      <h1><a href="/">Frame of 42yeah</a></h1>
      <h2>粒子系统！</h2>
      <hr />
      <section>
        <div style="margin-bottom: -25px">
  <div id='MicrosoftTranslatorWidget' class='Dark' style='color:white;background-color:inherit;height:30px;'></div>
</div>

<script type='text/javascript'>
  setTimeout(function(){
    {var s=document.createElement('script');s.type='text/javascript';s.charset='UTF-8';s.src=((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=ueOIGRSKkd965FeEGM5JtQ**&ctf=False&ui=true&settings=Manual&from=';var p=document.getElementsByTagName('head')[0]||document.documentElement;p.insertBefore(s,p.firstChild); }
  },0);
</script>
<script type='text/javascript' src='//www.bing.com/widget/bootstrap.js' data-id='cc2030a35e7345a1940e909993402b13' data-version='1.0b' data-autosnapshot='false' async></script>
        <p>我已经大概有很久很久没有看过 OpenGL 了吧……所以我决定今天看一哈，于是我恢复了我龟速的进度，也就是 <a href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">这里</a> 。于是，咱们来总结一下我看了的内容。</p>

<p>OpenGL 的 <a href="https://www.khronos.org/opengl/wiki/Buffer_Object">VBO</a> 是很灵活的。从我的个人理解来说，它就是一条储存在 GPU 里边的数组。所以，我们不仅可以在一开始的时候直接用 <a href="https://www.khronos.org/opengl/wiki/GLAPI/glBufferData"><code class="highlighter-rouge">glBufferData</code></a> 来初始化他，还可以用很多很多的方法！这里是官方文档给出的：</p>

<ul>
  <li><a href="https://www.khronos.org/opengl/wiki/GLAPI/glBufferData"><code class="highlighter-rouge">glBufferData</code></a> 可以初始化一个 VBO ，具体的参数是:
    <ul>
      <li><code class="highlighter-rouge">target</code>: 可以从这些里边选一个: <code class="highlighter-rouge">GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, </code> 或者 <code class="highlighter-rouge">GL_UNIFORM_BUFFER</code>。通常都选择 <code class="highlighter-rouge">GL_ARRAY_BUFFER</code>……吧？</li>
      <li><code class="highlighter-rouge">size</code>: 第三个参数的大小</li>
      <li><code class="highlighter-rouge">data</code>: 可以是指向一个数组的指针，也可以是 <code class="highlighter-rouge">NULL/nullptr</code> 。如果是后边那个的话，会给你初始化一个 <code class="highlighter-rouge">size</code> 大的空 VBO(里边的值全为 0)。</li>
      <li><code class="highlighter-rouge">usage</code>: 可以从这些里边选一个: <code class="highlighter-rouge">GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, </code> 或者 <code class="highlighter-rouge">GL_DYNAMIC_COPY</code>。别的我不太清楚，但是如果选了 <code class="highlighter-rouge">GL_STATIC_DRAW</code>，那每一次 <code class="highlighter-rouge">glBufferData</code> 都会在显卡那边重新初始化 VBO 一次，导致如果重复调用的话会效率奇低。（虽然如果不需要的话那这个挺好的……）</li>
    </ul>
  </li>
  <li><a href="https://www.khronos.org/opengl/wiki/GLAPI/glBufferStorage"><code class="highlighter-rouge">glBufferStorage</code></a> 也可以初始化一个 VBO。但和上面那个不一样的是，这个东西初始化过之后，里面的内容再也不能用 <strong>这个和上面那个</strong> 再初始化一次了。参数很接近，但因为我没用到，这里就不给出来了。你可以上网查，或者你看到的上一条链接。</li>
</ul>

<p>……对，其实就两种，所以没有很多很多种方法。但是没关系！这不还是初始化好了吗？但是，这时别以为里边的内容就再也不能更改了！即使是通过 <a href="https://www.khronos.org/opengl/wiki/GLAPI/glBufferStorage"><code class="highlighter-rouge">glBufferStorage</code></a> 来初始化的，里面的内容也是可以更改的。这个感觉就像在 C++ 里边来了一句 <code class="highlighter-rouge">char * const buf</code> 一样吧……指针不能再改了，但不代表里边的内容不能改:</p>

<ul>
  <li><a href="https://www.khronos.org/opengl/wiki/GLAPI/glMapBufferRange"><code class="highlighter-rouge">glMapBufferRange</code></a> 跟 <a href="https://www.khronos.org/opengl/wiki/GLAPI/glMapBuffer"><code class="highlighter-rouge">glMapBuffer</code></a> 都是很好的方法。现在我们假设你已经有了一个初始化完毕的 VBO ，并且已经绑定好了。这个时候你只需要 <code class="highlighter-rouge">void *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY)</code> 就能把对应的内存给映射出来，接下来你就可以好像操作一块正常内存一样操作这片区间了。但在修改完之后欧，记住要 <code class="highlighter-rouge">glUnmapBuffer(GL_ARRAY_BUFFER)</code> 就行了。在 Unmap 之后，指针会变成无效的，所以……也不需要 free 了。</li>
  <li><a href="https://www.khronos.org/opengl/wiki/GLAPI/glBufferSubData"><code class="highlighter-rouge">glBufferSubData</code></a> 是另外一种更改里面的内容的方法，其实我觉得可能就是这里第一条的一个封装（？）虽然跟 <code class="highlighter-rouge">glBufferData</code> 样子差不多，但实际上在特定情况下作用是完全不一样的，譬如说 <code class="highlighter-rouge">glBufferSubData</code> 必须要用在一条已经初始化好的 VBO 上。官方文档那边说: “看你怎么用，可能会特别浪费性能。” 但我还是用了，感觉一点也不慌。</li>
</ul>

<p>于是现在我们知道了有什么初始化 VBO 的数组，还有怎么修改一个已经初始化过的 VBO 了。我们发现了 VBO 很灵活，那实际上，可不可以根据 <code class="highlighter-rouge">glMapBuffer</code> 或者 <code class="highlighter-rouge">glBufferSubData</code> 来进行每一桢对 VBO 的修改呢？答案是可以的！而且实际上，这个很可能就是 Instancing 出来之前大家对粒子系统的实现（毕竟一帧一次 glBufferData 太浪费内存了）。所以说干就干，马上开写！</p>

<p><img src="/assets/particles.png" alt="粒子系统！" /></p>

<p>经过了一会儿的脑热和半个小时左右的 debug ，终于写好了……话说 OpenGL debug 是真的费时间……有的时候什么都看不到，就看到一个黑屏还是很绝望的……有的时候看到的不是黑屏，显示效果却很迷，又一时不知道为什么，就更绝望了……</p>

<p>我的粒子系统其实就是一开始先 book 好 1000 个点:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// generate points</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PARTICLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">());</span>
    <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后进入主循环，对于每一个点都看一次，如果对应的点是 alive 的，我们则根据他的运动方向更新他。如果不 alive ，我们就生成他。但是一帧只生成一个点，避免爆破式增长（虽然程序运行一开始还是爆破式增长了……）：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 生成一个点, 如果点满了就杀一个，然后更新其他的</span>
<span class="kt">int</span> <span class="n">furthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 离得最远的索引</span>
<span class="kt">bool</span> <span class="n">spacious</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 是不是还有空位</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果这个点活着，并且这个点比最远的还要离得更远，并且我们已经没有更多点可以用了，</span>
    <span class="c1">// 那他就是我们的新的最远的点了（准备把这个点删掉）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spacious</span> <span class="o">&amp;&amp;</span>
        <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">furthest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果活着，我们就根据这个点的运动方向，移动一下这个点</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">living</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span> <span class="o">+=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果这个点没活着，挺好，那之后大概也没有活着的点了（点满1000个的时候，因为每一帧都是生成一个，销毁一个，所有的点都应该永远活着</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">spacious</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">furthest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 我们假设他是离得最远的</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，还记得上面那串代码的 furthest 吗？这个东西记录的索引要不就是最远，也就是 <strong>准备被删然后在原位重新生成</strong>，要不就是 <strong>准备生成</strong> 的。所以实际上，我们完全可以把这个当成 “我们准备在这里创建一个新的粒子” 的点。怪我没命名好，可以叫 <code class="highlighter-rouge">gen</code> 什么的:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">alive</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">direction</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">((</span><span class="n">distrib</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">distrib</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                               <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 随机生成个新的方向，给点走</span>
</code></pre></div></div>

<p>这样一来，一个粒子系统就完工啦！</p>

<p><img src="/assets/animated.gif" alt="会动！" /></p>

<p>这里是完整的源码，注释会少一点（因为有些注释是我写这个的时候加的）：</p>

<h2 id="maincpp">main.cpp</h2>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "../include/glad/glad.h"
#include &lt;GLFW/glfw3.h&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;random&gt;
#include &lt;glm/glm.hpp&gt;
</span>
<span class="cp">#include "utility.hpp"
</span>

<span class="cp">#define MAX_PARTICLES 1000
</span>

<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">direction</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">alive</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">alive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span><span class="p">)</span> <span class="p">{</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// init glfw</span>
    <span class="n">glfwInit</span><span class="p">();</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_FORWARD_COMPAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>

    <span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">"buffer"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

    <span class="n">gladLoadGL</span><span class="p">();</span>


    <span class="c1">// compile programs!</span>
    <span class="n">GLuint</span> <span class="n">prog</span> <span class="o">=</span> <span class="n">program</span><span class="p">(</span><span class="s">"shaders/vertex.glsl"</span><span class="p">,</span> <span class="s">"shaders/fragment.glsl"</span><span class="p">);</span>

    <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">glPointSize</span><span class="p">(</span><span class="mf">20.0</span><span class="n">f</span><span class="p">);</span>


    <span class="c1">// generate points</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_PARTICLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">());</span>
        <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// get random machine up &amp; running!</span>
    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">device</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">distrib</span><span class="p">;</span>


    <span class="n">GLuint</span> <span class="n">VAO</span><span class="p">,</span> <span class="n">VBO</span><span class="p">;</span>
    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">MAX_PARTICLES</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">GL_DYNAMIC_DRAW</span><span class="p">);</span>

    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>


    <span class="kt">float</span> <span class="n">past</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">now</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
        <span class="kt">float</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">past</span><span class="p">;</span>
        <span class="n">past</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

        <span class="n">glfwPollEvents</span><span class="p">();</span>

        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>

        <span class="n">glUseProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">);</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">living</span> <span class="o">=</span> <span class="n">alive</span><span class="p">(</span><span class="n">points</span><span class="p">);</span>
        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">living</span><span class="p">);</span>

        <span class="c1">// gen one particles, kill one if too much, and move others</span>
        <span class="kt">int</span> <span class="n">furthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">spacious</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spacious</span> <span class="o">&amp;&amp;</span>
                <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">furthest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">living</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span> <span class="o">+=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">direction</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
                <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">alive</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">spacious</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">furthest</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">alive</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
        <span class="n">points</span><span class="p">[</span><span class="n">furthest</span><span class="p">].</span><span class="n">direction</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">((</span><span class="n">distrib</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                                       <span class="p">(</span><span class="n">distrib</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                                       <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>

        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>那就这样啦！</p>

      </section>
      <h2 id="评论区">评论区</h2>
<div id="disqus_thread" style="font-size: 12px !important;"></div>
<script>
  var disqus_config = function () {
    this.page.url = "https://potion4.github.io/cg/2019/01/18/opengl-particles.html";
    this.page.identifier = "粒子系统！";
  };

  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://frame-of-42yeah.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>
  </body>
</html>
