<!doctype html>
<html lang="zh">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="msvalidate.01" content="D1B532AF972A1AB6C3525C904A9AC816" />
  <meta name="google-site-verification" content="-ujy_zWUIaX-QJ4vdUYfXThyZgr_KqsU0lL611rqsy8" />
  <title>WebAssembly 中的多线程</title>
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/app.js"></script>
</head>

  <body>
    <div id="contentPane" class="huge-page real main">
      <h1><a href="/">Frame of 42yeah</a></h1>
      <h2>WebAssembly 中的多线程</h2>
      <hr />
      <section>
        <div style="margin-bottom: -25px">
  <div id='MicrosoftTranslatorWidget' class='Dark' style='color:white;background-color:inherit;height:30px;'></div>
</div>

<script type='text/javascript'>
  setTimeout(function(){
    {var s=document.createElement('script');s.type='text/javascript';s.charset='UTF-8';s.src=((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?siteData=ueOIGRSKkd965FeEGM5JtQ**&ctf=False&ui=true&settings=Manual&from=';var p=document.getElementsByTagName('head')[0]||document.documentElement;p.insertBefore(s,p.firstChild); }
  },0);
</script>
<script type='text/javascript' src='//www.bing.com/widget/bootstrap.js' data-id='cc2030a35e7345a1940e909993402b13' data-version='1.0b' data-autosnapshot='false' async></script>
        <p>我们总会在某个时候用到多线程的，无论是文件读写，异或是 socket I/O ，总之在某个时候，我们肯定是要用到这个玩意儿的。那么 WebAssembly 对这玩意儿的支持如何呢？我们先来欣赏一下这一片源代码：</p>

<h2 id="出发">出发！</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>

<span class="kt">void</span> <span class="nf">count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Counting "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">worker</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
        <span class="n">worker</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不难看出，这就是平平无奇的数数。好像的确如此。那我们现在马上编译 + 运行吧！</p>

<p><img src="/assets/uh_oh.png" alt="错了……" /></p>

<p>这个奇怪的什么 abort 是啥玩意儿？</p>

<h2 id="提出问题">提出问题</h2>

<p>那问题就来了。为什么会有这个奇怪的问题呢？结果其实就是 emscripten 默认是没有打开多线程支持的。如果要带着多线程支持去编译，那编译的时候必须加上 <code class="highlighter-rouge">-s USE_PTHREADS=1</code> 这个条件才行。来到了这里，就必须要说说 emscripten 多线程的方法了。因为说到底，Webassembly 只是一个字节码的解析机，所以 emscripten 所做的多线程不是真正的多线程；<a href="https://kripken.github.io/emscripten-site/docs/porting/pthreads.html">在 POSIX Thread API 的下面，他的实现方法其实是套用了 Web Worker 。</a> 也就是说，真正的、是不是究竟是多线程，还是由你的浏览器的实现方法说了算的。</p>

<p>废话结束，我们再编译一次：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>em++ threads/main.cpp <span class="nt">-o</span> threads/threads.html <span class="nt">-s</span> <span class="nv">EXTRA_EXPORTED_RUNTIME_METHODS</span><span class="o">=</span><span class="s2">"[ 'ccall', 'cwrap' ]"</span> <span class="nt">-s</span> <span class="nv">USE_PTHREADS</span><span class="o">=</span>1
</code></pre></div></div>

<p>好了！测试开始！</p>

<p><img src="/assets/hmm.png" alt="又错了……" /></p>

<p>……嘛意思弟弟？</p>

<h2 id="再次提出问题">再次提出问题</h2>
<p>不过其实这次的错误已经挺明显了，<a href="https://github.com/kripken/emscripten/issues/7581">上网一找就能搜到对应的 issue。</a>或者说如果你有点开上一个链接的话，并且认真看过一下的话，也能发现这一句话：</p>

<blockquote>
  <p>2018 年 1 月份打后，因为 <a href="https://meltdownattack.com/">Spectre</a> 大部分浏览器都关掉了 SharedArrayBuffer 功能。直到他被修好之前，这个功能都会默认关闭。但是你随时都可以通过在浏览器中通过设置对应的 flag 来打开。</p>
</blockquote>

<p><sup>注意: 当你看到这个日志的时候，我不知道这漏洞是不是已经被修好了。如果修好了就评论一句呗，我好把它去掉。</sup></p>

<p>浏览器的设置不难打开，如果你忘了我可以给你：</p>
<ul>
  <li><a href="about:config">Firefox 入口</a>: <code class="highlighter-rouge">about:config</code></li>
  <li><a href="about:flags">Chrome 入口</a>: <code class="highlighter-rouge">about:flags</code></li>
</ul>

<p>浏览器不给加载本地内容的话，直接复制链接到新窗口粘贴就可以了。</p>

<p>打开完了之后，这里以我的 Chromium 为例，搜索 WebAssembly:</p>

<p><img src="/assets/there_you_go.png" alt="在这里" /></p>

<p>Firefox 的选项应该也很接近吧。把它打开就完事了。你可能需要重启浏览器，但最后这个应该是你看到的效果：</p>

<p><img src="/assets/horray.png" alt="OK 了" /></p>

<h2 id="题内话">题内话</h2>
<p>最后，说多一句题内话，编译的时候，可以增加多一个选项</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-s</span> <span class="nv">PTHREAD_POOL_SIZE</span><span class="o">=</span>X
</code></pre></div></div>

<p>其中 X 是你想一开始就预留好的线程。这样做的话，可以在创建线程的时候省点时间。<strong>注意，这个选项不是允许的最大线程数，而是预分配多少条线程！</strong> 如果 X = -1 的话，浏览器会弹窗问你要预留多少条，debug 起来方便。</p>

<h2 id="测试">测试！</h2>
<p>如果你按着我的做法去做的话，或者你就是想看看效果的话，我这里可以给你做个输出的示范（我用了 <code class="highlighter-rouge">s PTHREAD_POOL_SIZE=3</code>，你可能在输出那看到他预留了三条线程的消息）：</p>

<p><a href="javascript:_start()">开始！</a></p>

<p id="output" style="font-family: sourcecode;"></p>
<script>
    let output = document.getElementById("output")

    var Module = {
        print: function(what) {
            output.innerHTML += what + "<br />"
        }
    }
</script>

<script src="/assets/threads.js"></script>

<h2 id="题外话">题外话</h2>
<p>再说多一句题外话，没想到这么简单的东西都能说这么一大堆，我决定以后这些简单的东西就说少一点了……</p>

<p>还有就是，今天考完线代了，从简单的一批到难得一批，感觉有点凉。。。</p>

<p>最后的最后，还要说一句，<strong>测试完就把那 flag 给关了吧……毕竟别人默认关闭不是没有理由的……</strong></p>

      </section>
      <h2 id="评论区">评论区</h2>
<div id="disqus_thread" style="font-size: 12px !important;"></div>
<script>
  var disqus_config = function () {
    this.page.url = "https://potion4.github.io/webassembly/2019/01/14/wasm-threading.html";
    this.page.identifier = "WebAssembly 中的多线程";
  };

  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://frame-of-42yeah.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>
  </body>
</html>
